## Logging

## Setting up your application for logging
1. Open the application we modified in __Lab5: Dependency Injection & Unit Testing__

1. Navigate to `Startup.cs` and change the `Configure` method to request an `ILogger<Startup>`:
```cs
    public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILogger<Startup> startupLogger)
    {
        ...
    }
```

2. Add a log statement to the end of the `Configure` method:
```cs
    public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILogger<Startup> startupLogger)
    {
        ...
        startupLogger.LogInformation("Application startup complete!");
    }
```

3. In Visual Studio, change the active launch host to the application itself (self-host) by navigating to the play/run button and changing the drop-down to the entry named after the application.
      ![image](Images/run-with-kestrel.png)

1. Run the application and browse to the application root. You should see the default log messages from the framework as well as your custom log message in the console window.

## Filtering logs
1. Add more logging statements to the `Configure` method:
```cs
    public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILogger<Startup> startupLogger)
    {
        ...
        startupLogger.LogInformation("Application startup complete!");

        startupLogger.LogCritical("This is a critical message");
        startupLogger.LogDebug("This is a debug message");
        startupLogger.LogTrace("This is a trace message");
        startupLogger.LogWarning("This is a warning message");
        startupLogger.LogError("This is an error message");
    }
```

1. Open or create `appsettings.json` in the project root. Add this node to configure the Console provider to log all Trace or higher messages:
```json
"Logging": {
    "Console": {
      "LogLevel": {
        "Default": "Trace"
      }
  }
}
```

1. Run the application. You should see more verbose logging from the framework and `Startup` including messages of all levels.

1. Add a log filter in `Program.cs` to configure the Console provider to only show logs from the `Startup` category:

```cs
        private static void SetupAppLogging(WebHostBuilderContext context, ILoggingBuilder loggingBuilder)
        {
            ...

            loggingBuilder.AddFilter<ConsoleLoggerProvider>((category, level) => {
                return category == typeof(Startup).FullName;
            });
        }
```

1. Run the application. You should see only logs written by the Startup logger.

> **Note:** Completed code for this section is found at [/Labs/Code/Lab6A](/Labs/Code/Lab6A-Logging).

## Adding other logging providers
1. Add references to the following Serilog NuGet packages:
   * "Serilog.Extensions.Logging"
   * "Serilog.Sinks.File"

1. Configure Serilog in `Startup.cs` to write to a file called `logfile.txt` in the project root (adding usings for `System.IO` and `Serilog`):

```cs
    public Startup(IConfiguration configuration)
    {
        Configuration = configuration;

        Log.Logger = new LoggerConfiguration()
            .WriteTo.File(logFile)
            .CreateLogger();
    }
```

3. Add the Serilog provider in `ConfigureServices`:

```cs
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddLogging(logBuilder =>
        {
            logBuilder.AddFilter<ConsoleLoggerProvider>((category, level) =>
                category == typeof(Startup).FullName
            );
            logBuilder.AddSerilog();
        });
    }
```

4. Run the application. You should observe `logfile.txt` appear in your application root.

1. Close the conosle window and open the file, the application logs should be in there.

> **Note:** Completed code for this section is found [/Labs/Code/Lab4B](/Labs/Code/Lab4B).

## Extra
1. Try adding more advanced filters with different levels.
1. Try configuring logging using the Configuration system (`IConfiguration`).

# Diagnostic pages

## Write some buggy code

1. Add a middleware to the above application that throws an exception. Your `Configure` method should look something like this:

```cs
    public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILogger<Startup> startupLogger)
    {
        if (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }

        app.Run(context => throw new InvalidOperationException("Oops!"));

        app.Run(async (context) =>
        {
            await context.Response.WriteAsync("Hello World!");
        });
        ...
    }
```

## Understanding the diagnostics middleware

1. Observe that the `Configure()` method in `Startup.cs` includes a call to configure the developer experience middleware when running in the Development environment. Ensure that your new buggy code occurs after the exception page is wired up, as shown below:

```cs
    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }

    app.Run(context => throw new InvalidOperationException("Oops!"));
```

2. Open the Project Properties dialog. On the Debug tab, ensure the `ASPNETCORE_ENVIRONMENT` variable is set to "Development".

1. Run the application and browse to it. You should see an application exception page (if you have first-chance exceptions on, continue after the debugger breaks).

## Adding a handler for non-development environments

1. Add exception handler middleware to the `Configure` method. Make sure it only runs when not in development:

```cs
    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }
    else
    {
        app.UseExceptionHandler(subApp =>
        {
            subApp.Run(async context =>
            {
                context.Response.ContentType = "text/html";
                await context.Response.WriteAsync("<strong> Application error. Please contact support. </strong>");
                await context.Response.WriteAsync(new string(' ', 512));  // Padding for IE
            });
        });
    }
```

1. Run the application in "Production" and browse to it. You should see the custom error page instead of the exception details.

> **Note:** Completed code for this section is found [/Labs/Code/Lab4C](/Labs/Code/Lab4C).

## Showing custom pages for non 500 status codes

1. Change the middleware throwing the exception message to instead set a 404 status code:

```cs
    app.Run(context =>
    {
        context.Response.StatusCode = 404;
        return Task.FromResult(0);
    });
```

2. Add the status code pages middleware above the exception handling middleware in `Configure`. The `{0}` will get replaced by the middleware with the status code when the status code is in the range of 400-599:

```cs
    public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILogger<Startup> startupLogger)
    {
        app.UseStatusCodePages("text/html", "<p>You got a <strong>{0}</strong></p>");
        if (env.IsDevelopment())
        {
            ...
```
3. Run the application and browse to it. You should see the custom error page instead of the browser's default 404 page.

> **Note:** Completed code for this section is found [/Labs/Code/Lab4D](/Labs/Code/Lab4D).

## Extra
1. Access the exception when using the exception handler middleware, log a custom message for it. (**Note: The exception handler middleware does log the exception via the logging system.**)
2. Serve an HTML page when an exception occurs using the static files middleware and the exception handler middleware.
3. Serve an HTML page for a 404 status using the static files middleware and status code pages middleware.
4. Write a custom logging provider
